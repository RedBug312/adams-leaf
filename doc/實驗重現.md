以下分別說明三組實驗：

1. 不同演算法之成本比較
2. 不同演算法之效能比較
3. ACO遺忘性 v.s. 效能分析

## 不同演算法之成本比較 ##
在`ACO演算法架構`中已說明，我們設計了一個成本函式，每個路由解可以都可據此計算出`成本`。這個實驗考慮 `SPF`、`RO`、`ACO`、`ACO without reroute` 四種演算法，分析它們給出的解的成本。

以下逐項說明如何重現實驗結果。

1. 確認 `FAST_STOP` 常數為 `false`，`T_LIMIT` 常數為 `10*1000`。
    - 確保程式會老老實實執行10毫秒。
2. 開啟 evaluate.sh，確認第二行的內容如下：
    * `./target/release/adams_leaf $1 test_graph.json test_flow.json test_flow.json 1`
    * 此即實驗結果中的 `RAND` 測資。
3. 執行 `./evaluate.sh spf` 得到 SPF 的成本。
4. 執行 `./evaluate.sh ro` 得到 RO 的成本。
5. 確認 `AVB_MEMORY`、`TSN_MEMORY` 皆為3。
6. 執行 `./evaluate.sh aco` 得到 ACO 的成本。
7. 將 `AVB_MEMORY`、`TSN_MEMORY` 皆改為9999999.9（總之隨便一個大數）。
8. 執行 `./evaluate.sh aco` 得到 ACO without reroute 的成本。
    - 因為記憶性變得超大，導致舊有路徑不可能被重排。
9. 開啟 evaluate.sh，確認第二行的內容如下：
    * `./target/release/adams_leaf $1 exp_graph.json exp_flow_light.json exp_flow_light.json 1`
10. 重複 3~8 過程。此即實驗結果中的 `MOTV_LIGHT` 測資。
11. 開啟 evaluate.sh，確認第二行的內容如下：
    * `./target/release/adams_leaf $1 exp_graph.json exp_flow_mid.json exp_flow_mid.json 1`
12. 重複 3~8 過程。此即實驗結果中的 `MOTV_MID` 測資。
13. 開啟 evaluate.sh，確認第二行的內容如下：
    * `./target/release/adams_leaf $1 exp_graph.json exp_flow_heavy.json exp_flow_heavy.json 1`
14. 重複 3~8 過程。此即實驗結果中的 `MOTV_HEAVY` 測資。

## 不同演算法之效能比較 ##

## ACO遺忘性 v.s. 效能分析 ##