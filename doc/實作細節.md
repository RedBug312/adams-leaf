
# 總述 #
本文件旨在說明 `src/` 資料夾中 rust 程式碼的實作細節。以下將分為三個主要模組進行討論，依序為：

1. 泛用模組 (util)
    - 即一些較泛用的工具，如最短路徑算法等。
2. 圖模組 (graph_util)
    - 即記錄網路拓樸的資料結構。
3. 路由算法 (routing_algos)
    - 包含本專案欲比較的三個算法：`Shortest Path First (SPF)`、`Routing Optimism (RO)`、`Ant Colony Optimization (ACO)`

# 泛用模組 #
包含以下工具，皆是 rust 類別：
1. djkstra 最短路徑算法
2. yens_algo K條最短路徑算法
3. my_min_heap 最小堆資料結構（標準庫有現成的，我應該是為了練習才實作……）
4. aco 蟻群優化算法

1~3工具有許多已知的實作方式，不再贅述，這裡主要解說 `aco` 工具的使用方式。

## util/aco ##
蟻群算法是一種迭代算法，多用來求解NP完備問題。不妨假設問題的`規模`是10，問題的`維度`是3，並有一個`成本評估函式`，其輸出是一個陣列而輸出為正實數。演算法旨在輸出一個長度為10的整數數列，每個元素只能是0或1或2（受維度所限），此陣列的成本應趨近最小（即用窮舉法找出的全域最小值）。

除此之外，我們還應該提供`能見度(Visibility)`，一個 10x3 的正實數陣列，代表我們對特定的解有洞見，可能加速算法收斂（當然用得不好就變成偏見）。能見度在迭代中不會改變。

`費洛蒙(Peromon)`同樣是一個 10x3 的正實數陣列。與能見度不同的是，費洛蒙會隨著每次迭代而改變，代表我們在迭代過程中學會的經驗，某些解就是表現得比別人好。費洛蒙通常不需要我們操心，視為私有變數就好，雖然我暴露了它的 getter，但只是為了除錯方便。

由於迭代特性，算法並沒有明確的終止條件，因此我們為計算時間設定上限，一但超時就叫停演算法並輸出結果。此外，還有一個`自訂停止條件`，例如 *當成本低於100且計算超過一秒，就終止*。至於如何操作這個條件，見稍後 `do_aco` 的說明。

### ACO - new ###
```rust
pub fn new(state_len: usize, k: usize, tao0: Option<f64>) -> Self;
```
ACO 是一個類別，需要初使化一個實例。
* `state_len` - 即問題的規模。
* `k` - 即問題的維度。
* `tao0` - 決定費洛蒙的初始值，若為 None 則使用預設初使值。

### ACO - extend_state_len ###
```rust
pub fn extend_state_len(&mut self, new_len: usize);
```
很不幸，本算法不是算一次就能結束，可能得動態擴增問題的規模（但不考慮擴增問題的維度），例如本來有10筆資料流突然增為15筆。此處 `new_len` 即是新的規模。

### ACO - do_aco ##
```rust
pub fn do_aco<F>(
    &mut self,
    time_limit: u128,
    visibility: &Vec<[f64; MAX_K]>,
    mut judge_func: F,
) -> State
where F: FnMut(&State) -> ACOJudgeResult;
```
這個函式就是整個模組存在的意義！

* `time_limit` - 演算法執行的時限。單位是微秒。
* `visibility` - 能見度。
    - 注意能見度不是在 `new` 的時候給定，而是在算答案前
    - 原因是：在動態情境中可能要反覆 do_aco -> extend_state_len -> do_aco ......
    - 每次擴增問題規模當然都會伴隨新的能見度，所以乾脆等真的要算的時候再給定吧！
* `judge_func` - 成本評估函式，後述。
* `輸出` - 這裡的 `State` 只是個別稱，它就是整數陣列，也就是我們朝思暮想的那個解。

關於成本評估函式，此處使用了函數式編程，直接將函式當成參數來傳遞。匿名函式唯一的參數就是那個整數陣列，吐出來的 ACOJudgeResult 則是成本……以及，是否應該叫停演算法。

這涉及算法的`自訂停止條件`，我將它整合到成本評估函式中。具體來說，ACOJudgeResult 是一個枚舉，分別有 `Stop` 及 `KeepOn` 兩種值，如果成本評估函式計算得95，已達停止條件（假設該條件是成本低於100)，就回傳 `ACOJudgeResult::Stop(98)`；反之若它計算得105，未達停止條件，就回傳 `ACOJudgeResult::KeepOn(105)`。

### ACO - 單元測試 ###
看一下單元測試可能會更有感。
```rust
fn test_aco() {
    // 實例化一個 ACO 物件，規模為0，維度為2，不設定初始費洛蒙。
    let mut aco = ACO::new(0, 2, None);
    // 將規模擴增為10
    aco.extend_state_len(10);
    // 讓算法執行50毫秒，能見度為一個10x2陣列，所有值皆為1.0（所有維度是平等的），後接成本評估函式。
    let new_state = aco.do_aco(50000, &vec![[1.0; MAX_K]; 10], |state| {
        // 就不細說下面這幾行在幹嘛了，總之成本最小的解是 [0, 1, 0, 1, 0, 1, 0, 1, 0, 1]
        let mut cost = 6.0;
        for (i, &s) in state.iter().enumerate() {
            if i % 2 == 0 {
                cost += s as f64;
            } else {
                cost -= s as f64;
            }
        }
        // 永遠回傳 KeepOn，代表沒有自訂終止條件。
        ACOJudgeResult::KeepOn(cost / 6.0)
    });
    assert_eq!(vec![0, 1, 0, 1, 0, 1, 0, 1, 0, 1], new_state);
}
```

> #### 再深入一點 ####
> 其實，此工具與經典蟻群算法不完全一致，主要表現在以下幾點：
> - 費洛蒙有最大值和最小值。
>     * 最大值用來防止某些路徑費洛蒙衝太大，完全支配路由結果，落入局部最佳解。
>     * 最小值用來防止某些路徑費洛蒙降太低，以致於完全選不到。
> - 選擇路徑時，不一定完全是隨機的，有一個 `Q0` 的機率可能會直接選費洛蒙最大者。
> - 更新費洛蒙時，並不是造出一個新解就更新一次，而是會先造出 `R` 個解，從中選出 `L` 個成本最低者。這 `L` 個解才有資格更新費洛蒙。
>     * 這可以說是一種偷懶──我不用搜索枯腸設計出一個性質夠漂亮的成本函式，因為競爭過程幫我把太垃圾的解丟棄了，剩下的解都有一定的代表性。
>
> 這些特性都可視為黑箱，只會影響優化效率，無涉公有接口，所以不用太在意。

# 圖模組 #
也就是網路拓樸，由節點（包含終端設備與交換機）和邊所組成，包含三個東西：

1. trait `Graph`，最基本的圖上操作。
2. trait `OnOffGraph`，繼承 Graph 並多了一些功能，可以禁用某一條邊。
    - 只是用來加速 Yen's Algorithm 的，不用太深究，大膽跳過它吧！
3. struct `StreamAwareGraph`，實作上面兩個 trait，另外還有一些小功能用來加速成本估計函式。

## Graph ##
這個 trait 中定義了一些基本操作，新增刪除節點、邊等等。每個節點會被賦與ID，我為了泛用性，用一個泛型`K`代表之，所以它可以是整數，或大整數，或字元。~~後來發現只是徒增困擾。~~

值得探討者有：
```rust
pub trait Graph<K: Hash + Eq>: Clone {
    // 其它基本操作……
    
    // 給定一個路徑，得到它的長度（邊有距離，並非每條邊等長）
    fn get_dist(&self, path: &Vec<K>) -> f64;

    // 給定一個 ID 為 id 的節點，遍歷所有的邊。
    // 比方說，節點乙與節點甲、丙相連，距離甲10，距離丙20，則回調函式就會被呼叫兩次。
    // 第一次的參數是(甲, 10)，第二次參數是(丙, 20)。
    fn foreach_edge(&self, id: K, callback: impl FnMut(K, f64) -> ());

    // 遍歷圖上所有節點，並不重要，整個程式裡都沒用到……
    fn foreach_node(&self, callback: impl FnMut(K, bool) -> ());
}
```

## StreamAwareGraph ##
這個類別不但實作了上面兩個 trait，還多了四個公有方法，前三個是為了加速成本估計函式用的。概念是，這個圖能 *察覺(aware)* 在它身上走過的資料流，並將此資訊記錄在邊上。下一次，我只要問：「節點甲和節點乙中間這條邊，有哪些資料流走過了？」圖就會乖乖告訴我：「是丙資料流、丁資料流和……」

第四個方法`get_links_id_bandwidth`是為了加速 GCL 排程用的，這裡就不多贅述。

### StreamAwareGraph - update_flowid_on_route ###
```rust
pub fn update_flowid_on_route(&mut self, remember: bool, flow_id: usize, route: &Vec<usize>);
```
* `remember` - 布林值，若為真，代表要把 flow_id 記憶到圖上；若為否，代表把 flow_id 忘掉。
* `flow_id` - 資料流的識別碼。
* `route` - 資料流的路徑。為一個非負整數向量，記錄沿途會經過的節點識別碼。
例如，甲資料流發生了一次 reroute，則應該用`update_flowid_on_route(false, 甲, 舊路徑)`把舊路徑忘掉，再用`update_flowid_on_route(false, 甲, 新路徑)`記憶新路徑。

### StreamAwareGraph - forget_all_flows ###
```rust
pub fn forget_all_flows(&mut self);
```
顧名思義，不願再承受，把所有資料流忘記。

### StreamAwareGraph - get_overlap_flows ###
```rust
pub fn get_overlap_flows(&self, route: &Vec<usize>) -> Vec<Vec<usize>>;
```
由於程式的性質使然，其實我們不會真的去問一條邊上有誰經過，重點是一整條路徑上有多少人跟我重疊。需注意的是，方向不同不視為重疊，例如我問的是從節點甲到節點乙這條路，則乙到甲的路就與我無關。
* `route` - 欲詢問之路徑。沿途節點識別碼。
* `輸出` - 向量的向量。假設 route 途經5個邊，則輸出的長度亦為5，每個元素仍是向量。第n個元素向量，代表「在 route 第n條邊上，有哪些資料流經過？列出它們的識別碼。」因此元素向量的長度並不固定。

# 路由算法 #
這個模組很大一包，其實應該再切細一點的……