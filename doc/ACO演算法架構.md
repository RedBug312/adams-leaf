```flow
st=>start: (0) Yen's Algorithm
idle=>operation: (1) 閒置
reconf=>inputoutput: 新資料流到來
init_sol=>operation: (2) 產生初始路由解
init_ph=>operation: (3) 初始化/繼承費洛蒙
init_vis=>operation: (4) 初始化能見度
new_sol=>operation: (5) 產生新路由解
comp_cost=>operation: (6) 計算成本，決定是否記錄
update_ph=>operation: (7) 更新費洛蒙
cond=>condition: (8) 計算時間是否超過上限？
output=>inputoutput: 輸出最佳路由解

st->idle->reconf->init_sol->init_ph->init_vis->new_sol->comp_cost->update_ph->cond
cond(yes)->output
cond(no)->new_sol
output->idle
```

0. 用 `Yen's Algorithm` 選出任兩個終端間的前 `K` 條最短路徑。
    - 直觀上，我們認為即使最短路徑不見得最佳，但一個好的解仍不太可能是由太長的路徑組合起來的。
1. 閒置，等待新的 reconfigure 要求。
2. 新的資料流安排最短路徑，舊資料流則維持原路徑，以此策略生成一組初始解。
3. 初始化/繼承`費洛蒙`。
    - __每個資料流__ 的 __每個候選路徑__ 都需要有費洛蒙。
    - 對新資料流，安排一個固定的常數作為費洛蒙（見`常數與自定義名詞.md`）。
    - 對舊資料流，使用 __前一次蟻群算法中產生之費洛蒙__。
4. 初始化`能見度`。
    - 依照不同特性（如長度、擁擠度等等），賦與 __每個資料流__ 的 __每個候選路徑__ 一個能見度。
    - 目前計算能見度的方法：AVB 為 Worst Case Delay 之倒數，TSN 為路徑長之倒數。
        * 言下之意為，延遲越高或路徑越長的路徑 *越不可見*，越不易被蟻群算法選中。
    - 此外，對於一個舊資料流而言，`原有路徑`的能見度會被乘上一個`記憶常數`。
        * 言下之意為，原有路徑比其它路徑 *更可見*，從而確保演算法比較喜歡守舊的解，討厭 reroute 舊資料流。
        * `記憶常數`對解的品質非常重要，太大則演算法失去彈性，太小則演算法無所適從。實驗三就是在討論這個問題。
5. 產生新路由解。
    - 此為一個亂數過程，對於每個資料流，從它的 `K` 個候選路徑中挑出一個。
    - 任一候選路徑被選中的機率，與`費洛蒙`與`能見度`的乘積成正比。
6. 對於一個解，我們需要一個指標來估計它到底 *有多好*。該指標即`成本函式`。
    - 目前的成本函式分為三個小項目：
        1. 若 TSN 不可排程，給予一個大懲罰項。
        2. 與 AVB 的 WCD 成正比。
        3. 若 AVB 的 WCD 超過給定的上限，另給一個大懲罰項。
    - 遇見成本新低的解就記錄下來（廢話）。
7. 根據前一步算出的`成本`，更新`費洛蒙`。
    - 首先將本來的費洛蒙乘上一個`蒸發率`，得到新費洛蒙。
    - 對步驟6的解所含的那些候選路徑，再將費洛蒙加上成本的倒數。
        * 言下之意為，成本越大，費洛蒙增加的幅度越小，之後越不容易被選中。
8. 本演算法以時間為終止條件。